#include <iostream>
#include <cmath>

using namespace std;

class Matrix {

private:
    unsigned h, w;
    double** mtx;

public:
    Matrix();
    Matrix(unsigned h, unsigned w);
    Matrix(const Matrix& matrix);
    ~Matrix();

    Matrix& T();
    bool is_square();
    bool is_diagonal();
    bool is_zero();
    bool is_eye();
    bool is_symm();
    bool is_up_triangle();
    bool is_down_triangle();


    Matrix& operator=(const Matrix& m);
    friend Matrix& operator+(const Matrix& m, const Matrix& m2);
    friend Matrix& operator-(const Matrix& m, const Matrix& m2);
    friend Matrix& operator*(const Matrix& m, const Matrix& m2);
    friend Matrix& operator+(const Matrix& m, double s);
    friend Matrix& operator-(const Matrix& m, double s);
    friend Matrix& operator*(const Matrix& m, double s);
    friend Matrix& operator/(const Matrix& m, double s);
    Matrix& operator+=(const Matrix& m);
    Matrix& operator-=(const Matrix& m);
    Matrix& operator*=(const Matrix& m);
    Matrix& operator+=(double);
    Matrix& operator-=(double);
    Matrix& operator*=(double s);
    Matrix& operator/=(double s);
    bool operator==(const Matrix& m);
    bool operator!=(const Matrix& m);


    friend ostream& operator<<(ostream& os, const Matrix& m);
    friend istream& operator>>(istream& is, const Matrix& m);

    unsigned const get_width();
    unsigned const get_height();

};


Matrix::Matrix() {
    this->w = 0;
    this->h = 0;
}


Matrix::Matrix(unsigned h, unsigned w) {
    cout << "size contructor" << endl;
    if (w == 0 || h == 0) {
        throw(1);
    }

    this->w = w;
    this->h = h;

    this->mtx = (double**)malloc(sizeof(double*) * h);
    for (unsigned i = 0; i < h; i++)
    {
        this->mtx[i] = (double*)malloc(sizeof(double) * w);
    }

    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < w; j++) {
            this->mtx[i][j] = 0;
        }
    }
}

Matrix::Matrix(const Matrix& matrix) {
    this->w = matrix.w;
    this->h = matrix.h;

    this->mtx = (double**)malloc(sizeof(double*) * matrix.h);
    for (unsigned i = 0; i < matrix.h; i++)
    {
        this->mtx[i] = (double*)malloc(sizeof(double) * matrix.w);
    }

    for (unsigned i = 0; i < matrix.h; i++) {
        for (unsigned j = 0; j < matrix.w; j++) {
            this->mtx[i][j] = matrix.mtx[i][j];
        }
    }

}

Matrix& Matrix::T() {
    Matrix* m = new Matrix(this->w, this->h);  //auto
    for (unsigned i = 0; i < this->h; i++) {
        for (unsigned j = 0; j < this->w; j++) {
            m->mtx[j][i] = this->mtx[i][j];
        }
    }
    return *m;
}


Matrix& Matrix::operator=(const Matrix& matrix) {
    this->w = matrix.w;
    this->h = matrix.h;
    this->mtx = (double**)malloc(sizeof(double*) * matrix.h);
    for (unsigned i = 0; i < matrix.h; i++)
    {
        this->mtx[i] = (double*)malloc(sizeof(double) * matrix.w);
    }

    for (unsigned i = 0; i < matrix.h; i++) {
        for (unsigned j = 0; j < matrix.w; j++) {
            this->mtx[i][j] = matrix.mtx[i][j];
        }
    }
    return *this;
}


Matrix& Matrix::operator+=(const Matrix& matrix) {
    *this = *this + matrix;
    return *this;
}


Matrix& Matrix::operator-=(const Matrix& matrix) {
    *this = *this - matrix;
    return *this;
}


Matrix& Matrix::operator*=(const Matrix& matrix) {
    *this = *this * matrix;
    return *this;
}


Matrix& Matrix::operator+=(double s) {
    *this = *this + s;
    return *this;
}


Matrix& Matrix::operator-=(double s) {
    *this = *this - s;
    return *this;
}


Matrix& Matrix::operator*=(double s) {
    *this = *this * s;
    return *this;
}


Matrix& Matrix::operator/=(double s) {
    if (s == 0) throw 1;
    *this = *this / s;
    return *this;
}


Matrix& operator+(const Matrix& m, const Matrix& m2) {
    if (m.w != m2.w || m.h != m2.h) throw 1;
    Matrix* tmp = new Matrix(m);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            tmp->mtx[i][j] += m2.mtx[i][j];
        }
    }
    return *tmp;
}


Matrix& operator-(const Matrix& m, const Matrix& m2) {
    if (m.w != m2.w || m.h != m2.h) throw 1;
    Matrix* tmp = new Matrix(m);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            tmp->mtx[i][j] -= m2.mtx[i][j];
        }
    }
    return *tmp;
}


Matrix& operator*(const Matrix& m, const Matrix& m2) {
    if (m.w != m2.h) throw 1;
    Matrix* tmp = new Matrix(m.h, m2.w);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m2.w; j++) {
            double s = 0;
            for (unsigned k = 0; k < m.w; k++) {
                s += m.mtx[i][k] * m2.mtx[k][j];
            }
            tmp->mtx[i][j] = s;
        }
    }
    return *tmp;
}


Matrix& operator+(const Matrix& m, double s) {
    Matrix* tmp = new Matrix(m);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            tmp->mtx[i][j] += s;
        }
    }
    return *tmp;
}


Matrix& operator-(const Matrix& m, double s) {
    Matrix* tmp = new Matrix(m);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            tmp->mtx[i][j] -= s;
        }
    }
    return *tmp;
}


Matrix& operator*(const Matrix& m, double s) {
    Matrix* tmp = new Matrix(m);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            tmp->mtx[i][j] *= s;
        }
    }
    return *tmp;
}

Matrix& operator/(const Matrix& m, double s) {
    if (s == 0) throw 1;
    Matrix* tmp = new Matrix(m);
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            tmp->mtx[i][j] /= s;
        }
    }
    return *tmp;
}


bool Matrix::operator==(const Matrix& m) {
    if (w != m.w || h != m.h) {
        return false;
    }
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < w; j++) {
            if (mtx[i][j] != m.mtx[i][j]) {
                return false;
            }
        }
    }
    return true;
}


bool Matrix::operator!=(const Matrix& m) {
    return !(*this == m);
}


unsigned const Matrix::get_width() {
    return this->w;
}

unsigned const Matrix::get_height() {
    return this->h;
}


ostream& operator<<(ostream& os, const Matrix& m) {
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            os << m.mtx[i][j] << " ";
        }
        os << endl;
    }
    return os;
}


istream& operator>>(istream& is, const Matrix& m) {
    for (unsigned i = 0; i < m.h; i++) {
        for (unsigned j = 0; j < m.w; j++) {
            is >> m.mtx[i][j];
        }
    }
    return is;
}


Matrix::~Matrix() {
    if (this->h == 0 && this->w == 0) {
        return;
    }
    for (unsigned i = 0; i < this->h; i++)
    {
        free(this->mtx[i]);
    }
    free(this->mtx);
}


bool Matrix::is_square() {
    return this->w == this->h;
}


bool Matrix::is_diagonal() {
    if (!this->is_square()) {
        return false;
    }
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < w; j++) {
            if (i != j && mtx[i][j] != 0) {
                return false;
            }
        }
    }
    return true;
}


bool Matrix::is_zero() {
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < w; j++) {
            if (mtx[i][j] != 0) {
                return false;
            }
        }
    }
    return true;
}


bool Matrix::is_eye() {
    if (!this->is_square()) {
        return false;
    }
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < w; j++) {
            if (i != j && mtx[i][j] != 0 || i == j && mtx[i][j] != 1) {
                return false;
            }
        }
    }
    return true;
}

bool Matrix::is_symm() {
    if (!this->is_square()) {
        return false;
    }
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < w; j++) {
            if (mtx[i][j] != mtx[j][i]) {
                return false;
            }
        }
    }
    return true;
}

bool Matrix::is_up_triangle() {
    if (!this->is_square()) {
        return false;
    }
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = 0; j < i; j++) {
            if (mtx[i][j] != 0) {
                return false;
            }
        }
    }
    return true;
}

bool Matrix::is_down_triangle() {
    if (!this->is_square()) {
        return false;
    }
    for (unsigned i = 0; i < h; i++) {
        for (unsigned j = i + 1; j < w; j++) {
            if (mtx[i][j] != 0) {
                return false;
            }
        }
    }
    return true;
}


Matrix& user_input_matrix(string m_name = "") {
    while (true) {
        cout << "Input " << m_name << " matrix shape [h, w]: ";
        int h, w;
        cin >> h >> w;
        if (h <= 0 || w <= 0) {
            cout << "incorrect shape!" << endl;
            continue;
        }
        cout << "Input data (" << h * w << " numbers): " << endl;
        Matrix* m = new Matrix(h, w);
        cin >> *m;
        cout << "Thanks! Your matrix is: " << endl << *m;
        return *m;
    }
}

double user_input_number(void) {
    double s;
    cout << "Input your number : ";
    cin >> s;
    cout << "Thanks! Yur number is: " << endl << s << endl;
    return s;
}

void interactive_session() {
    bool stop = false;
    while (!stop) {
        cout << "Choose action to do with matrices:" << endl;
        cout << "0. Exit" << endl;
        cout << "1. Add two matrices" << endl;
        cout << "2. Subtraction of two matrices" << endl;
        cout << "3. Add scalar to matrix" << endl;
        cout << "4. Subtract scalar from matrix" << endl;
        cout << "5. Multiply matrix by a matrix" << endl;
        cout << "6. Multiply matrix by a scalar" << endl;
        cout << "7. Divide matrix by scalar" << endl;
        cout << "8. Transpose matrix" << endl;
        cout << "9. Check if matrix is square" << endl;
        cout << "10. Check if matrix is eye" << endl;
        cout << "11. Check if matrix is null" << endl;
        cout << "12. Check if matrix is diagonal" << endl;
        cout << "13. Check if matrix is symmetrical" << endl;
        cout << "14. Check if matrix is up-triangle" << endl;
        cout << "15. Check if matrix is down-triangle" << endl;
        cout << "16. Compare two matricies" << endl;
        cout << "17. Check +=" << endl;
        cout << "18. Check -=" << endl;
        cout << "19. Check *=" << endl;
        cout << "20. Check *= SCALAR" << endl;
        cout << "21. Check /= SCALAR" << endl;
        cout << "22. Check !=" << endl;



        int cmd;
        cin >> cmd;
        if (cmd < 0 || cmd > 22) {
            cout << " Invalid command. Try once more." << endl;
            continue;
        }
        Matrix m1, m2, m3;
        double s;
        switch (cmd) {
        case 0:
            stop = true;
            break;
        case 1:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            try {
                m3 = m1 + m2;
                cout << "Result of A + B:" << endl << m3;
            }
            catch (const int& er) {
                cout << "Invalid sizes!" << endl;
            }
            break;
        case 2:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            try {
                m3 = m1 - m2;
                cout << "Result of A - B:" << endl << m3;
            }
            catch (const int& er) {
                cout << "Invalid sizes!" << endl;
            }
            break;
        case 3:
            m2 = user_input_matrix("A");
            s = user_input_number();
            m2 += s;
            cout << "Result of A + s:" << endl << m2;
            break;
        case 4:
            m1 = user_input_matrix("A");
            s = user_input_number();
            m2 -= s;
            cout << "Result of A - s:" << endl << m2;
            break;
        case 5:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            try {
                m3 = m1 * m2;
                cout << "Result of A * B:" << endl << m3;
            }
            catch (const int& er) {
                cout << "Invalid sizes!" << endl;
            }
            break;
        case 6:
            m1 = user_input_matrix("A");
            s = user_input_number();
            m1 = m1 * s;
            cout << "Result: " << endl << m1 << endl;
            break;
        case 7:
            m1 = user_input_matrix("A");
            s = user_input_number();
            try {
                m1 = m1 / s;
                cout << "Result: " << endl << m1 << endl;
            }
            catch (const int& er) {
                cout << "Dividing by zero!" << endl;
            }
            break;
        case 8:
            m1 = user_input_matrix("A");
            m1 = m1.T();
            cout << "Result: " << endl << m1 << endl;
            break;
        case 9:
            m1 = user_input_matrix("A");
            if (m1.is_square()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 10:
            m1 = user_input_matrix("A");
            if (m1.is_eye()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 11:
            m1 = user_input_matrix("A");
            if (m1.is_zero()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 12:
            m1 = user_input_matrix("A");
            if (m1.is_diagonal()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 13:
            m1 = user_input_matrix("A");
            if (m1.is_symm()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 14:
            m1 = user_input_matrix("A");
            if (m1.is_up_triangle()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 15:
            m1 = user_input_matrix("A");
            if (m1.is_down_triangle()) {
                cout << "Yes" << endl;
            }
            else {
                cout << "No" << endl;
            }
            break;
        case 16:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            if (m1 == m2) {
                cout << "Equal" << endl;
            }
            else {
                cout << "Not equal" << endl;
            }
            break;
        case 17:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            try {
                m1 += m2;
                cout << "Result of A += B:" << endl << m2;
            }
            catch (const int& er) {
                cout << "Invalid sizes!" << endl;
            }
            break;
        case 18:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            try {
                m1 -= m2;
                cout << "Result of A -= B:" << endl << m2;
            }
            catch (const int& er) {
                cout << "Invalid sizes!" << endl;
            }
            break;
        case 19:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            try {
                m1 *= m2;
                cout << "Result of A *= B:" << endl << m1;
            }
            catch (const int& er) {
                cout << "Invalid sizes!" << endl;
            }
            break;
        case 20:
            m1 = user_input_matrix("A");
            s = user_input_number();
            m1 *= s;
            cout << "Result: " << endl << m1 << endl;
            break;
        case 21:
            m1 = user_input_matrix("A");
            s = user_input_number();
            try {
                m1 /= s;
                cout << "Result: " << endl << m1 << endl;
            }
            catch (const int& er) {
                cout << "Dividing by zero!" << endl;
            }
            break;
        case 22:
            m1 = user_input_matrix("A");
            m2 = user_input_matrix("B");
            if (m1 != m2) {
                cout << "Not equal" << endl;
            }
            else {
                cout << "Equal" << endl;
            }
            break;
        }
    }
}


int main()
{
    interactive_session();

    return 0;
};
